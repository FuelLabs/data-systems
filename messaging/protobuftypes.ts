// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.7
//   protoc               v3.21.12
// source: protobuftypes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "./google/protobuf/any";

export const protobufPackage = "protobuftypes";

export interface TestBlock {
  v1?: BlockV1 | undefined;
}

export interface BlockV1 {
  header: BlockHeader | undefined;
  transactions: Transaction[];
}

export interface Transaction {
  script?: Script | undefined;
}

export interface Script {
  body: ScriptBody | undefined;
  policies: Policies | undefined;
  inputs: Uint8Array[];
  outputs: Uint8Array[];
  witnesses: Uint8Array[];
}

export interface Policies {
  values: number[];
  data: Any | undefined;
}

export interface ScriptBody {
  scriptGasLimit: number;
  receiptsRoot: Uint8Array;
  script: ScriptCode | undefined;
  scriptData: Uint8Array;
}

export interface ScriptCode {
  bytes: Uint8Array;
}

export interface BlockHeader {
  v1?: BlockHeaderV1 | undefined;
  v2?: BlockHeaderV1 | undefined;
}

export interface BlockHeaderV1 {
  application: ApplicationHeader | undefined;
  consensus: ConsensusHeader | undefined;
  metadata: BlockHeaderMetadata | undefined;
}

export interface BlockHeaderMetadata {
  id: number;
}

export interface ApplicationHeader {
  daHeight: number;
  consensusParametersVersion: number;
  stateTransitionBytecodeVersion: number;
  generated: GeneratedApplicationFields | undefined;
}

export interface GeneratedApplicationFields {
  transactionsCount: number;
  messageReceiptCount: number;
  transactionsRoot: Uint8Array;
  messageOutboxRoot: Uint8Array;
  eventInboxRoot: Uint8Array;
}

export interface ConsensusHeader {
  prevRoot: Uint8Array;
  height: number;
  time: number;
  generated: GeneratedConsensusFields | undefined;
}

export interface GeneratedConsensusFields {
  applicationHash: Uint8Array;
}

export interface MyDemoType {
  name: string;
  age: number;
  isActive: boolean;
}

export interface Request {
  pubKeyRequest?: PubKeyRequest | undefined;
  pubKeyResponse?: PubKeyResponse | undefined;
}

export interface PubKeyRequest {
  id: string;
  data: Uint8Array;
}

export interface PubKeyResponse {
  id: string;
  data: Uint8Array;
}

function createBaseTestBlock(): TestBlock {
  return { v1: undefined };
}

export const TestBlock: MessageFns<TestBlock> = {
  encode(message: TestBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.v1 !== undefined) {
      BlockV1.encode(message.v1, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.v1 = BlockV1.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestBlock {
    return { v1: isSet(object.v1) ? BlockV1.fromJSON(object.v1) : undefined };
  },

  toJSON(message: TestBlock): unknown {
    const obj: any = {};
    if (message.v1 !== undefined) {
      obj.v1 = BlockV1.toJSON(message.v1);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestBlock>, I>>(base?: I): TestBlock {
    return TestBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestBlock>, I>>(object: I): TestBlock {
    const message = createBaseTestBlock();
    message.v1 = (object.v1 !== undefined && object.v1 !== null) ? BlockV1.fromPartial(object.v1) : undefined;
    return message;
  },
};

function createBaseBlockV1(): BlockV1 {
  return { header: undefined, transactions: [] };
}

export const BlockV1: MessageFns<BlockV1> = {
  encode(message: BlockV1, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      BlockHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockV1 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockV1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockV1 {
    return {
      header: isSet(object.header) ? BlockHeader.fromJSON(object.header) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BlockV1): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = BlockHeader.toJSON(message.header);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockV1>, I>>(base?: I): BlockV1 {
    return BlockV1.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockV1>, I>>(object: I): BlockV1 {
    const message = createBaseBlockV1();
    message.header = (object.header !== undefined && object.header !== null)
      ? BlockHeader.fromPartial(object.header)
      : undefined;
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return { script: undefined };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.script !== undefined) {
      Script.encode(message.script, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.script = Script.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return { script: isSet(object.script) ? Script.fromJSON(object.script) : undefined };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.script !== undefined) {
      obj.script = Script.toJSON(message.script);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.script = (object.script !== undefined && object.script !== null)
      ? Script.fromPartial(object.script)
      : undefined;
    return message;
  },
};

function createBaseScript(): Script {
  return { body: undefined, policies: undefined, inputs: [], outputs: [], witnesses: [] };
}

export const Script: MessageFns<Script> = {
  encode(message: Script, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body !== undefined) {
      ScriptBody.encode(message.body, writer.uint32(10).fork()).join();
    }
    if (message.policies !== undefined) {
      Policies.encode(message.policies, writer.uint32(18).fork()).join();
    }
    for (const v of message.inputs) {
      writer.uint32(26).bytes(v!);
    }
    for (const v of message.outputs) {
      writer.uint32(34).bytes(v!);
    }
    for (const v of message.witnesses) {
      writer.uint32(42).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Script {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScript();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.body = ScriptBody.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.policies = Policies.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputs.push(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputs.push(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.witnesses.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Script {
    return {
      body: isSet(object.body) ? ScriptBody.fromJSON(object.body) : undefined,
      policies: isSet(object.policies) ? Policies.fromJSON(object.policies) : undefined,
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => bytesFromBase64(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => bytesFromBase64(e)) : [],
      witnesses: globalThis.Array.isArray(object?.witnesses)
        ? object.witnesses.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: Script): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = ScriptBody.toJSON(message.body);
    }
    if (message.policies !== undefined) {
      obj.policies = Policies.toJSON(message.policies);
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => base64FromBytes(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => base64FromBytes(e));
    }
    if (message.witnesses?.length) {
      obj.witnesses = message.witnesses.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Script>, I>>(base?: I): Script {
    return Script.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Script>, I>>(object: I): Script {
    const message = createBaseScript();
    message.body = (object.body !== undefined && object.body !== null)
      ? ScriptBody.fromPartial(object.body)
      : undefined;
    message.policies = (object.policies !== undefined && object.policies !== null)
      ? Policies.fromPartial(object.policies)
      : undefined;
    message.inputs = object.inputs?.map((e) => e) || [];
    message.outputs = object.outputs?.map((e) => e) || [];
    message.witnesses = object.witnesses?.map((e) => e) || [];
    return message;
  },
};

function createBasePolicies(): Policies {
  return { values: [], data: undefined };
}

export const Policies: MessageFns<Policies> = {
  encode(message: Policies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.uint64(v);
    }
    writer.join();
    if (message.data !== undefined) {
      Any.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.values.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policies {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
      data: isSet(object.data) ? Any.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: Policies): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Math.round(e));
    }
    if (message.data !== undefined) {
      obj.data = Any.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Policies>, I>>(base?: I): Policies {
    return Policies.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Policies>, I>>(object: I): Policies {
    const message = createBasePolicies();
    message.values = object.values?.map((e) => e) || [];
    message.data = (object.data !== undefined && object.data !== null) ? Any.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseScriptBody(): ScriptBody {
  return { scriptGasLimit: 0, receiptsRoot: new Uint8Array(0), script: undefined, scriptData: new Uint8Array(0) };
}

export const ScriptBody: MessageFns<ScriptBody> = {
  encode(message: ScriptBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scriptGasLimit !== 0) {
      writer.uint32(8).uint64(message.scriptGasLimit);
    }
    if (message.receiptsRoot.length !== 0) {
      writer.uint32(18).bytes(message.receiptsRoot);
    }
    if (message.script !== undefined) {
      ScriptCode.encode(message.script, writer.uint32(26).fork()).join();
    }
    if (message.scriptData.length !== 0) {
      writer.uint32(34).bytes(message.scriptData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScriptBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScriptBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.scriptGasLimit = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.receiptsRoot = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.script = ScriptCode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scriptData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScriptBody {
    return {
      scriptGasLimit: isSet(object.scriptGasLimit) ? globalThis.Number(object.scriptGasLimit) : 0,
      receiptsRoot: isSet(object.receiptsRoot) ? bytesFromBase64(object.receiptsRoot) : new Uint8Array(0),
      script: isSet(object.script) ? ScriptCode.fromJSON(object.script) : undefined,
      scriptData: isSet(object.scriptData) ? bytesFromBase64(object.scriptData) : new Uint8Array(0),
    };
  },

  toJSON(message: ScriptBody): unknown {
    const obj: any = {};
    if (message.scriptGasLimit !== 0) {
      obj.scriptGasLimit = Math.round(message.scriptGasLimit);
    }
    if (message.receiptsRoot.length !== 0) {
      obj.receiptsRoot = base64FromBytes(message.receiptsRoot);
    }
    if (message.script !== undefined) {
      obj.script = ScriptCode.toJSON(message.script);
    }
    if (message.scriptData.length !== 0) {
      obj.scriptData = base64FromBytes(message.scriptData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScriptBody>, I>>(base?: I): ScriptBody {
    return ScriptBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScriptBody>, I>>(object: I): ScriptBody {
    const message = createBaseScriptBody();
    message.scriptGasLimit = object.scriptGasLimit ?? 0;
    message.receiptsRoot = object.receiptsRoot ?? new Uint8Array(0);
    message.script = (object.script !== undefined && object.script !== null)
      ? ScriptCode.fromPartial(object.script)
      : undefined;
    message.scriptData = object.scriptData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseScriptCode(): ScriptCode {
  return { bytes: new Uint8Array(0) };
}

export const ScriptCode: MessageFns<ScriptCode> = {
  encode(message: ScriptCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bytes.length !== 0) {
      writer.uint32(10).bytes(message.bytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScriptCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScriptCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScriptCode {
    return { bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array(0) };
  },

  toJSON(message: ScriptCode): unknown {
    const obj: any = {};
    if (message.bytes.length !== 0) {
      obj.bytes = base64FromBytes(message.bytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScriptCode>, I>>(base?: I): ScriptCode {
    return ScriptCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScriptCode>, I>>(object: I): ScriptCode {
    const message = createBaseScriptCode();
    message.bytes = object.bytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBlockHeader(): BlockHeader {
  return { v1: undefined, v2: undefined };
}

export const BlockHeader: MessageFns<BlockHeader> = {
  encode(message: BlockHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.v1 !== undefined) {
      BlockHeaderV1.encode(message.v1, writer.uint32(10).fork()).join();
    }
    if (message.v2 !== undefined) {
      BlockHeaderV1.encode(message.v2, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.v1 = BlockHeaderV1.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.v2 = BlockHeaderV1.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeader {
    return {
      v1: isSet(object.v1) ? BlockHeaderV1.fromJSON(object.v1) : undefined,
      v2: isSet(object.v2) ? BlockHeaderV1.fromJSON(object.v2) : undefined,
    };
  },

  toJSON(message: BlockHeader): unknown {
    const obj: any = {};
    if (message.v1 !== undefined) {
      obj.v1 = BlockHeaderV1.toJSON(message.v1);
    }
    if (message.v2 !== undefined) {
      obj.v2 = BlockHeaderV1.toJSON(message.v2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeader>, I>>(base?: I): BlockHeader {
    return BlockHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeader>, I>>(object: I): BlockHeader {
    const message = createBaseBlockHeader();
    message.v1 = (object.v1 !== undefined && object.v1 !== null) ? BlockHeaderV1.fromPartial(object.v1) : undefined;
    message.v2 = (object.v2 !== undefined && object.v2 !== null) ? BlockHeaderV1.fromPartial(object.v2) : undefined;
    return message;
  },
};

function createBaseBlockHeaderV1(): BlockHeaderV1 {
  return { application: undefined, consensus: undefined, metadata: undefined };
}

export const BlockHeaderV1: MessageFns<BlockHeaderV1> = {
  encode(message: BlockHeaderV1, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.application !== undefined) {
      ApplicationHeader.encode(message.application, writer.uint32(10).fork()).join();
    }
    if (message.consensus !== undefined) {
      ConsensusHeader.encode(message.consensus, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      BlockHeaderMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeaderV1 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeaderV1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.application = ApplicationHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consensus = ConsensusHeader.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = BlockHeaderMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeaderV1 {
    return {
      application: isSet(object.application) ? ApplicationHeader.fromJSON(object.application) : undefined,
      consensus: isSet(object.consensus) ? ConsensusHeader.fromJSON(object.consensus) : undefined,
      metadata: isSet(object.metadata) ? BlockHeaderMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: BlockHeaderV1): unknown {
    const obj: any = {};
    if (message.application !== undefined) {
      obj.application = ApplicationHeader.toJSON(message.application);
    }
    if (message.consensus !== undefined) {
      obj.consensus = ConsensusHeader.toJSON(message.consensus);
    }
    if (message.metadata !== undefined) {
      obj.metadata = BlockHeaderMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeaderV1>, I>>(base?: I): BlockHeaderV1 {
    return BlockHeaderV1.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeaderV1>, I>>(object: I): BlockHeaderV1 {
    const message = createBaseBlockHeaderV1();
    message.application = (object.application !== undefined && object.application !== null)
      ? ApplicationHeader.fromPartial(object.application)
      : undefined;
    message.consensus = (object.consensus !== undefined && object.consensus !== null)
      ? ConsensusHeader.fromPartial(object.consensus)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? BlockHeaderMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseBlockHeaderMetadata(): BlockHeaderMetadata {
  return { id: 0 };
}

export const BlockHeaderMetadata: MessageFns<BlockHeaderMetadata> = {
  encode(message: BlockHeaderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeaderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeaderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeaderMetadata {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: BlockHeaderMetadata): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeaderMetadata>, I>>(base?: I): BlockHeaderMetadata {
    return BlockHeaderMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeaderMetadata>, I>>(object: I): BlockHeaderMetadata {
    const message = createBaseBlockHeaderMetadata();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseApplicationHeader(): ApplicationHeader {
  return { daHeight: 0, consensusParametersVersion: 0, stateTransitionBytecodeVersion: 0, generated: undefined };
}

export const ApplicationHeader: MessageFns<ApplicationHeader> = {
  encode(message: ApplicationHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.daHeight !== 0) {
      writer.uint32(8).uint32(message.daHeight);
    }
    if (message.consensusParametersVersion !== 0) {
      writer.uint32(16).uint32(message.consensusParametersVersion);
    }
    if (message.stateTransitionBytecodeVersion !== 0) {
      writer.uint32(24).uint32(message.stateTransitionBytecodeVersion);
    }
    if (message.generated !== undefined) {
      GeneratedApplicationFields.encode(message.generated, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.daHeight = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.consensusParametersVersion = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stateTransitionBytecodeVersion = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.generated = GeneratedApplicationFields.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationHeader {
    return {
      daHeight: isSet(object.daHeight) ? globalThis.Number(object.daHeight) : 0,
      consensusParametersVersion: isSet(object.consensusParametersVersion)
        ? globalThis.Number(object.consensusParametersVersion)
        : 0,
      stateTransitionBytecodeVersion: isSet(object.stateTransitionBytecodeVersion)
        ? globalThis.Number(object.stateTransitionBytecodeVersion)
        : 0,
      generated: isSet(object.generated) ? GeneratedApplicationFields.fromJSON(object.generated) : undefined,
    };
  },

  toJSON(message: ApplicationHeader): unknown {
    const obj: any = {};
    if (message.daHeight !== 0) {
      obj.daHeight = Math.round(message.daHeight);
    }
    if (message.consensusParametersVersion !== 0) {
      obj.consensusParametersVersion = Math.round(message.consensusParametersVersion);
    }
    if (message.stateTransitionBytecodeVersion !== 0) {
      obj.stateTransitionBytecodeVersion = Math.round(message.stateTransitionBytecodeVersion);
    }
    if (message.generated !== undefined) {
      obj.generated = GeneratedApplicationFields.toJSON(message.generated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplicationHeader>, I>>(base?: I): ApplicationHeader {
    return ApplicationHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplicationHeader>, I>>(object: I): ApplicationHeader {
    const message = createBaseApplicationHeader();
    message.daHeight = object.daHeight ?? 0;
    message.consensusParametersVersion = object.consensusParametersVersion ?? 0;
    message.stateTransitionBytecodeVersion = object.stateTransitionBytecodeVersion ?? 0;
    message.generated = (object.generated !== undefined && object.generated !== null)
      ? GeneratedApplicationFields.fromPartial(object.generated)
      : undefined;
    return message;
  },
};

function createBaseGeneratedApplicationFields(): GeneratedApplicationFields {
  return {
    transactionsCount: 0,
    messageReceiptCount: 0,
    transactionsRoot: new Uint8Array(0),
    messageOutboxRoot: new Uint8Array(0),
    eventInboxRoot: new Uint8Array(0),
  };
}

export const GeneratedApplicationFields: MessageFns<GeneratedApplicationFields> = {
  encode(message: GeneratedApplicationFields, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionsCount !== 0) {
      writer.uint32(8).uint32(message.transactionsCount);
    }
    if (message.messageReceiptCount !== 0) {
      writer.uint32(16).uint32(message.messageReceiptCount);
    }
    if (message.transactionsRoot.length !== 0) {
      writer.uint32(26).bytes(message.transactionsRoot);
    }
    if (message.messageOutboxRoot.length !== 0) {
      writer.uint32(34).bytes(message.messageOutboxRoot);
    }
    if (message.eventInboxRoot.length !== 0) {
      writer.uint32(42).bytes(message.eventInboxRoot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratedApplicationFields {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratedApplicationFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionsCount = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageReceiptCount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transactionsRoot = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.messageOutboxRoot = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eventInboxRoot = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeneratedApplicationFields {
    return {
      transactionsCount: isSet(object.transactionsCount) ? globalThis.Number(object.transactionsCount) : 0,
      messageReceiptCount: isSet(object.messageReceiptCount) ? globalThis.Number(object.messageReceiptCount) : 0,
      transactionsRoot: isSet(object.transactionsRoot) ? bytesFromBase64(object.transactionsRoot) : new Uint8Array(0),
      messageOutboxRoot: isSet(object.messageOutboxRoot)
        ? bytesFromBase64(object.messageOutboxRoot)
        : new Uint8Array(0),
      eventInboxRoot: isSet(object.eventInboxRoot) ? bytesFromBase64(object.eventInboxRoot) : new Uint8Array(0),
    };
  },

  toJSON(message: GeneratedApplicationFields): unknown {
    const obj: any = {};
    if (message.transactionsCount !== 0) {
      obj.transactionsCount = Math.round(message.transactionsCount);
    }
    if (message.messageReceiptCount !== 0) {
      obj.messageReceiptCount = Math.round(message.messageReceiptCount);
    }
    if (message.transactionsRoot.length !== 0) {
      obj.transactionsRoot = base64FromBytes(message.transactionsRoot);
    }
    if (message.messageOutboxRoot.length !== 0) {
      obj.messageOutboxRoot = base64FromBytes(message.messageOutboxRoot);
    }
    if (message.eventInboxRoot.length !== 0) {
      obj.eventInboxRoot = base64FromBytes(message.eventInboxRoot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeneratedApplicationFields>, I>>(base?: I): GeneratedApplicationFields {
    return GeneratedApplicationFields.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeneratedApplicationFields>, I>>(object: I): GeneratedApplicationFields {
    const message = createBaseGeneratedApplicationFields();
    message.transactionsCount = object.transactionsCount ?? 0;
    message.messageReceiptCount = object.messageReceiptCount ?? 0;
    message.transactionsRoot = object.transactionsRoot ?? new Uint8Array(0);
    message.messageOutboxRoot = object.messageOutboxRoot ?? new Uint8Array(0);
    message.eventInboxRoot = object.eventInboxRoot ?? new Uint8Array(0);
    return message;
  },
};

function createBaseConsensusHeader(): ConsensusHeader {
  return { prevRoot: new Uint8Array(0), height: 0, time: 0, generated: undefined };
}

export const ConsensusHeader: MessageFns<ConsensusHeader> = {
  encode(message: ConsensusHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prevRoot.length !== 0) {
      writer.uint32(10).bytes(message.prevRoot);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint64(message.height);
    }
    if (message.time !== 0) {
      writer.uint32(24).uint64(message.time);
    }
    if (message.generated !== undefined) {
      GeneratedConsensusFields.encode(message.generated, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsensusHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsensusHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prevRoot = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.time = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.generated = GeneratedConsensusFields.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsensusHeader {
    return {
      prevRoot: isSet(object.prevRoot) ? bytesFromBase64(object.prevRoot) : new Uint8Array(0),
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      generated: isSet(object.generated) ? GeneratedConsensusFields.fromJSON(object.generated) : undefined,
    };
  },

  toJSON(message: ConsensusHeader): unknown {
    const obj: any = {};
    if (message.prevRoot.length !== 0) {
      obj.prevRoot = base64FromBytes(message.prevRoot);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.generated !== undefined) {
      obj.generated = GeneratedConsensusFields.toJSON(message.generated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsensusHeader>, I>>(base?: I): ConsensusHeader {
    return ConsensusHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsensusHeader>, I>>(object: I): ConsensusHeader {
    const message = createBaseConsensusHeader();
    message.prevRoot = object.prevRoot ?? new Uint8Array(0);
    message.height = object.height ?? 0;
    message.time = object.time ?? 0;
    message.generated = (object.generated !== undefined && object.generated !== null)
      ? GeneratedConsensusFields.fromPartial(object.generated)
      : undefined;
    return message;
  },
};

function createBaseGeneratedConsensusFields(): GeneratedConsensusFields {
  return { applicationHash: new Uint8Array(0) };
}

export const GeneratedConsensusFields: MessageFns<GeneratedConsensusFields> = {
  encode(message: GeneratedConsensusFields, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applicationHash.length !== 0) {
      writer.uint32(10).bytes(message.applicationHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratedConsensusFields {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratedConsensusFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applicationHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeneratedConsensusFields {
    return {
      applicationHash: isSet(object.applicationHash) ? bytesFromBase64(object.applicationHash) : new Uint8Array(0),
    };
  },

  toJSON(message: GeneratedConsensusFields): unknown {
    const obj: any = {};
    if (message.applicationHash.length !== 0) {
      obj.applicationHash = base64FromBytes(message.applicationHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeneratedConsensusFields>, I>>(base?: I): GeneratedConsensusFields {
    return GeneratedConsensusFields.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeneratedConsensusFields>, I>>(object: I): GeneratedConsensusFields {
    const message = createBaseGeneratedConsensusFields();
    message.applicationHash = object.applicationHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMyDemoType(): MyDemoType {
  return { name: "", age: 0, isActive: false };
}

export const MyDemoType: MessageFns<MyDemoType> = {
  encode(message: MyDemoType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.age !== 0) {
      writer.uint32(16).int32(message.age);
    }
    if (message.isActive !== false) {
      writer.uint32(24).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MyDemoType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMyDemoType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.age = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MyDemoType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      age: isSet(object.age) ? globalThis.Number(object.age) : 0,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
    };
  },

  toJSON(message: MyDemoType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.age !== 0) {
      obj.age = Math.round(message.age);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MyDemoType>, I>>(base?: I): MyDemoType {
    return MyDemoType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MyDemoType>, I>>(object: I): MyDemoType {
    const message = createBaseMyDemoType();
    message.name = object.name ?? "";
    message.age = object.age ?? 0;
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseRequest(): Request {
  return { pubKeyRequest: undefined, pubKeyResponse: undefined };
}

export const Request: MessageFns<Request> = {
  encode(message: Request, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pubKeyRequest !== undefined) {
      PubKeyRequest.encode(message.pubKeyRequest, writer.uint32(10).fork()).join();
    }
    if (message.pubKeyResponse !== undefined) {
      PubKeyResponse.encode(message.pubKeyResponse, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Request {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pubKeyRequest = PubKeyRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pubKeyResponse = PubKeyResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Request {
    return {
      pubKeyRequest: isSet(object.pubKeyRequest) ? PubKeyRequest.fromJSON(object.pubKeyRequest) : undefined,
      pubKeyResponse: isSet(object.pubKeyResponse) ? PubKeyResponse.fromJSON(object.pubKeyResponse) : undefined,
    };
  },

  toJSON(message: Request): unknown {
    const obj: any = {};
    if (message.pubKeyRequest !== undefined) {
      obj.pubKeyRequest = PubKeyRequest.toJSON(message.pubKeyRequest);
    }
    if (message.pubKeyResponse !== undefined) {
      obj.pubKeyResponse = PubKeyResponse.toJSON(message.pubKeyResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Request>, I>>(base?: I): Request {
    return Request.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Request>, I>>(object: I): Request {
    const message = createBaseRequest();
    message.pubKeyRequest = (object.pubKeyRequest !== undefined && object.pubKeyRequest !== null)
      ? PubKeyRequest.fromPartial(object.pubKeyRequest)
      : undefined;
    message.pubKeyResponse = (object.pubKeyResponse !== undefined && object.pubKeyResponse !== null)
      ? PubKeyResponse.fromPartial(object.pubKeyResponse)
      : undefined;
    return message;
  },
};

function createBasePubKeyRequest(): PubKeyRequest {
  return { id: "", data: new Uint8Array(0) };
}

export const PubKeyRequest: MessageFns<PubKeyRequest> = {
  encode(message: PubKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubKeyRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: PubKeyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubKeyRequest>, I>>(base?: I): PubKeyRequest {
    return PubKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubKeyRequest>, I>>(object: I): PubKeyRequest {
    const message = createBasePubKeyRequest();
    message.id = object.id ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBasePubKeyResponse(): PubKeyResponse {
  return { id: "", data: new Uint8Array(0) };
}

export const PubKeyResponse: MessageFns<PubKeyResponse> = {
  encode(message: PubKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubKeyResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: PubKeyResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PubKeyResponse>, I>>(base?: I): PubKeyResponse {
    return PubKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PubKeyResponse>, I>>(object: I): PubKeyResponse {
    const message = createBasePubKeyResponse();
    message.id = object.id ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
